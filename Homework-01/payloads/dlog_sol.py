from Crypto.Util.number import *


# # 因為目標是要找到一個非常破碎的 p-1，才能有機會利用 Pohlig-Hellman 去爆破
# # 所以先嘗試生成一個很破碎的 prime p-1 且這個 p-1 長度逼近 1024
# p = 0
# while True:
#     p_find = False
#     # 利用 getPrime(32) 隨機產生一個 32-bit 的 prime，因為目標長度逼近 1024，所以要產生 32 個
#     p_1 = 2
#     for _ in range(32):
#         p_1 *= getPrime(32)
    
#     print(p_1.bit_length())
    
#     for _ in range(10000):
#         # 由於 getPrime(32) 並不一定會產生出 32-bit 的 prime，所以要利用補另一個 prime 來補足 1024-bits
#         p = p_1 * getPrime(1024 - p_1.bit_length()) + 1
#         if p.bit_length() == 1024 and isPrime(p):
#             p_find = True
#             break
    
#     print(p_find, p.bit_length())
    
#     if p_find:
#         break
# print(p)

# # 把這串丟到 SageMathCell 拿到 flag
# p = 111299370064906882197696170883187094864431275880225875107737139146305348587887490923063190779100557914408358898671290623524747281333040982349308354343361847094273643636773104474808861737708391454754116417210576588277182522232336976155604379929949140890264921765884674267255629260614725786856099732616052578427
# b = 2
# secret = 99197481246450929628826249466735868954977694915133311778124497443552359558534747415764014641196098881178869431890803192727048412186116587641905347571746369053299777903830434887561630215725305663204831001330517261494250884316698767105915874515326362633686333161100750242079291896387266394700304776498306107895

# b = Mod(b, p)
# secret = Mod(secret, p)
# flag = secret.log(b)

flag = 49364843843516391046524858268527194975796465451738728838358032889241583861681330662804867351377897795928696970286962956463589155540867567526290878080760609183681160756648327792284881716359474001233174433892064146380383612195159015622968516262648816463326620015840413743850502492696637091892320630355187856206
print(long_to_bytes(flag))
